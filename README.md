## 这主要记录我从0开始学习java的每一天写的一些代码和小笔记  



配套的教程是b站的一个999个视频的java教程,链接在下面  


[java基础+进阶](https://www.bilibili.com/video/BV1uJ411k7wy?p=84&spm_id_from=pageDriver)  
  
每天都会学一点点然后推送到github上面。
没有什么特别大的作用主要是记录  

# 2022.1.5
今天第一天学Java，发现很多的东西都忘记了。  

最基本的输入输出，方法在那块定义都忘记了。  

所以只能当小白第一个学。顺便复习了以下git的一些命令  

啊，忘记了好多东西
不知道现在才开始学还来不来得及
先专心学java把
把其他的事情放一边去。  

# 2022.1.6
java内存的划分  

java的内存其实可以划分为5个部分  

+ 栈内存（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中。  



>> 局部变量：方法的参数，或者方法{}内部的变量  

>> 作用域：一旦超出作用域，立刻从栈内存中消失  


+ 堆内存（Heap）：凡是new出来的东西，都在堆当中  



  
>> 堆内存里面的东西都有一个地址值：16进制  

>> 堆内存的数据都有默认值，规则：    

>> 如果是整数类型，默认为0  

>> 如果是浮点类型，默认为0。0  

>> 如果是字符类型，默认为'/u0000'  

>> 如果是布尔类型，默认为false  
 
>> 如果是引用类型，默认为null  

+ 方法区（Method Area） ：存储.class相关信息，包含方法信息。  
>> 你叫什么名字啊？你的参数是什么啊？ 返回类型是什么啊？

+ 本地方法栈（Native Method Stack）：与操作系统相关  

+ 本地寄存器（PC Register）：与CPU相关




今天比昨天学的久一点，希望明天不要睡这么久了，早点起来学习啊！！  
今天学的是数组，但是还没有学完数组可能要拖到明天啦  
# 2022.1.7
 今天把数组相关的基础知识复习完了  
 其中数组转置的方法是我自己写的，可能有很多不对的地方，跟视频里面写的是不一样的
> 任何数据类型都可以作为方法的参数类型，或者返回值类型
> 但是数组作为参数的时候，给到方法的是数组的地址值，作为返回值的时候，返回的其实也是数组的地址值  

怎么老不会用git好烦,怎么每次都要出问题!!  
刚刚用了强制覆盖，git push -u origin main -f才把代码推送上去
现在我在推送一次代码，推送的时候注释为fifth commit  我就不信我推不上去  
ok了  
现在记录一下推送代码的git命令 免得我明天又忘记了  

```git add . //保存所有的改动```

```git commit -m '注释信息'```

```git push -u origin main //把代码推送到远程 ``` 

记录完之后我再推一次明天就开始面向对象了 今天玩的比较多  
# 2022.1.8
今天开始真的学习java了，给自己定个小目标，一天学一章，开始面向对象啦～
+ 面向对象的三大特征：封装，继承和多态  
今天主要学习的是封装  
什么是类？  
类是对一类事物的描述，是抽象的
类是一组相关的属性和行为的集合（你是什么？能做什么？）  
什么是对象？  
对象是一类事物的实例，是具体的  
类是对象的模版，对象是类的实体  
成员方法保存在堆区里面，而且保存的是一个地址值，这个地址值指向方法区的那个成员方法  
栈当中完成一个成员方法之后，会马上出栈  
但是最开始进的卖弄方法需要在所有方法执行完毕之后再出栈  
今天就是把所有关于面向对象的最基础的知识学完了，顶不住了，听了22节课 886
# 2022.1.9
今天学习API，API就是程序员随意使用的字典  
今天主要学习一个键盘输入的类  
Scanner    
这个的用法就是接收用户从键盘输入的内容  格式也比较固定：  

```Scanner sc = new Scanner(System.in)```

还有ArrayList，集合，这个集合比较厉害，可以不指定大小，自己可以随便加东西进去  
但是必须是引用类型，如果想装基本类型，就需要使用包装类。    
ArrayList<E>里面的E就是泛型，举例一个  

```ArrayList<Integer> list = new ArrayList<>();```

在这个例子里面就使用了包装类，list就是这个集合的名字  
今天也学习了随机类的一些很简单的方法  
比如生成一个随机整数，范围是1-100：
```
Random r= new Random();
int num = r.nextInt(100)+1;
```  
至于为什么要加1呢，具体的解释在代码里面的注释写的有。  
还学习了一下匿名类，匿名类练的比较少，我只记住了他只能用一次，他没有名字  
假如我有一个Student类，我想创建一个匿名的，就向下面这样写：  

``` new Studnet().name="Tina" ```  

今天还做了四个很小很简单的ArrayList的练习，但是都是我自己先想然后敲的没有看视频的解法。  
另外我觉得三目运算符是真的好用又方便啊！  
# 2022.1.10
今天学习静态，字符串和常用的工具类  
字符串是什么？
String 类代表字符串，java中所有字符串字面值比如"abc" 都是字符串类的实例实现  
字符串是常量，他们的值在创建之后是不能更改的，字符串缓冲区指出可变的字符串。
因为String对象是不可变的。使用可以共享。  
静态关键字Static的概述  
一个类可能有很多对象，每个对象都要很多属性
比如说学生对象，他们有姓名年龄性别等等
假设我们给学生类加上一个所在教室，而且他们都是同班同学
那么他们这个属性的值都是相同的
意思就是说，对于姓名年龄这样的属性来说，每个对象都有自己的独立数据
但是对于所在教室来说，这应该是多个对象共享一份数据才行
就是只在类当中保存唯一一份，那所有本类对象共享一份  
在方法区当中，有个独立的部分，叫静态区，专门用来存放静态量只要有变量用到了，就存储他的地址值，然后指向该静态变量  
注意：根据类名访问静态成员变量的时候，全程和对象没有关系  
只和类有关系
# 2022.1.11
今天来学习继承和抽象  
继承是多态的前提，如果没有继承，就没有多态。  
继承主要解决的问题是共性问题。 父类也可以叫积类，超类。子类也可以叫派生类  
继承关系当中的特点： 

+ 子类可以拥有父类的""内容"
+ 子类还可以拥有直接专有的内容  

对于哪一个变量来说，不单单是父类变量和子类变量有可能发生重名  
局部变量和成员变量也会发生重名的问题  
继承设计原则：对于已经投入使用的类，尽量不要进行修改   
Java语言是单继承的，一个类的直接父类只能有一个。  
``` 
class A {}
class B extends A {}//正确
class C {}
class D extends A,C {}//错误,只能遗鸥一个父类
```
Java语言可以多级继承，但是不能一下有多个父类   
```
class A {}
class B extends A{}//正确
class C extends B{}//正确
```
一个子类的直接父类，但是一个父类可以同时拥有很多个子类。  
```
class A {}
class B extends A{}//正确
class c extends A{}//正确
```
抽象：  
假如说现在有一个父类，动物类，里面有一个方法，是动物吃东西的方法  
有一个动物类的子类为汪星人，另外一个动物类的子类为喵星人。狗吃骨头，猫吃鱼肉
```
class abstract Animal {
   public abstract void eat(){}
          }
class Dog extends Animal{
    public void eat(){}
          }
class Cat extends Animal{
    public void eat(){}
          }
```
我们知道猫吃鱼，狗吃骨头，但是我们不知道动物吃什么  
所以，如果父类当中的方法不确定如何进行方法体的实现  
那么这就应该是一个抽象方法  
抽象方法必须在抽象类当中，抽象的关键字abstract  
使用抽象类，有下面四点注意事项：  

+ 抽象类不能创建对象，如果创建，编译无法通过，只能创建其非抽象子类的对象
+ 抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的
+ 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类
+ 抽象类的子类，必须重写父类的所哟有抽象方法，否则编译无法通过，除非该子类也是抽象类  

今天做了一个案例是非常简单的发红包的实例，有很多地方需要自己想的我都没有想到，所以下来有空得好好想想。
# 2022.1.12
今天来学习接口
接口就是一种公共的规范标准。只要符合标准，就可以大家通用。  
在Java9+版本中，接口的内容可以有以下五点
+ 成员变量其实是常量，格式：  

```public static final 常量名称 = 数据值；```  

（常量必须进行赋值，一旦赋值不可改变。常量必须完全大写，用下划线进行分隔）
+ 接口中最重要的就是抽象方法，格式：  

```public abstract 返回值类型 方法名称（参数列表）;```  

（实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类）
+ 从Java8+开始，接口中允许定义默认方法，格式：  

```public default 返回值类型 方法名称（参数列表）{方法体}```  

（默认方法也可以被覆盖重写）  
+ 从Java8+开始，接口里允许定义静态方法，格式：  

```public static 返回值类型 方法名称（参数列表）{方法体}```  

（应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法）
+ 从Java9开始，接口允许定义私有方法，格式：

普通私有方法:

```private 返回值类型 方法名称 （参数列表）{方法体}```

静态私有方法: 

```private static 返回值类型 方法名称（参数列表）{方法体}```
（private方法只能由接口自己进行调用，不能被实现类或别的类进行调用）  

面向对象的三大特性：

封装继承多态

extends继承或者implements实现，是多态性的前提  

多态的好处：

无论右边new的时候换成哪个子类对象，等号左边的调用方法都不会变化  
举个例子：

现在有一个父类是员工Employee，里面有一个方法work();

然后有两个子类讲师类Teacher和一个助教类Assistant
他们都重写了一个方法work();Teacher中的work();是讲课。Assistant
中的work();是辅导
如果不使用多态，那么代码就应该写成  
```
Teacher teacher = new Teacher();
teacher.work();//讲课
Assistant assistant = new Assistant();
Assistant.work();//辅导
```
如果使用多态，那么代码就是
```
Employee teacher = new Teacher();
Employee assistant = new Assistant();
teacher.work();//讲课
assistant.work();//辅导
```
1，对象的向上转型，其实就是多态的写法；  
格式：

```父类名称 对象名 = new 子类名称();```

含义：右侧创建一个子类对象，把它当作父类来看待使用

注意事件：向上转型一定是安全的，从小范围转向了大范围。

2，对象的向下转型，其实是一个【还原】的动作。  
格式：

```子类对象 对象名 = (子类名称) 父类对象；```  

含义：将父类对象，【还原】成为本来的子类对象。

如果向下转型，只能转型成为本来的类型。不能转成其他类型，不然会出现ClassCastException（编译的时候不会出错，运行的时候会）

类似于：
```
int num = (int) 10.0//可以 
int num = (int) 10.5//不可以，精度损失
```

今天学的东西稍微有点多了，而且挺难的尤其是多态。现在我只记得，使用多态写法的时候，变量要看左边的，成员方法要看右边的，虽然我不是太理解为什么  
可能因为new的是右边的 ，所以有右边的 常量，但是方法使用的时候还是的看左边，如果子类没有重写他的方法，那么就使用左边的，如果重写了，那么就使用子类的
没有就向上找  

如果使用的是下转，那么就要看原来是什么类型，这个时候需要使用instanceof关键字

```对象 instanceof 类型```

下转就可以使用自己特有的方法了

就这样吧今天，主要是我不是太理解，所以我有点蒙






